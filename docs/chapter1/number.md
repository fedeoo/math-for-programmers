# 数的表示

众所周知，计算机以二进制形式存储和处理信息，计算机的数字都是用二进制表示的。表示负数可以使用补码编码，表示小数可以使用浮点数编码。这儿主要帮大家复习浮点数的表示。

## 日常遇到的问题

$0.1 + 0.2 \neq 0.3$ 

有经验的程序员对上面的不等式不会感到惊讶。以 JavaScript 为例 `$0.1 + 0.2` 得到的结果是 `0.30000000000000004`，两者不等不足为奇。

另外，浮点数的舍入也让人困惑：1.445 舍入两位是 1.45 而 1.435 舍入两位是 1.43 （C 和 JavaScript 得到的都是同样的结果）

## 浮点数的表示

IEEE 浮点标准用 $V = {(-1)^s} * M * 2^E$ 表示一个数：
- 符号 s 决定正负
- 有效数 M
- 指数 E

浮点数的位划分为三部分，编码这些值：
- 一个单独的符号位
- k 为的指数域 exp 编码 E
- n 位小数域 frac 编码 M
以 32 位单精度浮点数为例，s、exp 和 frac 分别为 1位、 k = 8 位 和 n = 23 位   

根据 exp 值不同，有三种情况
### 规格化值
exp 即非全 0 也非全 1   
指数值为 e - Bias 小数值为 1.frac   其中 $Bias = 2^{k-1} - 1$
小数域 frac 表示的数值为 f，其中 0 <= f < 1，其二进制表示为 $0.f_{n-1}...f_1f_0$，这是一个正常的二进制小数。注意：有效数定义为 M = 1 + f，也就是隐含以 1 为开头。我们可以这样理解 $M=1.f_{n-1}...f_1f_0$，因为 M 要表示的数都是以 1 为开头，干脆直接省去了。

### 非规格化值
exp 全 0 指数值为 1 - Bias 后面会解释为什么是 1 - Bias 而非 - Bias  

### 特殊值
exp 全 1 小数为为全0时表示无穷，否则表示 NaN (Not a Number)

下面以 k = 4, n = 3, Bias = 2^3 -1 = 7 为例 (CSAPP 书中的示例)

对于非规格化数，指数部分为 E = 1 - Bias = -6 所表示的数为小数部分乘以 $M*2^{-6}$

|描述|位表示|e|E|f|M|V|
|--- | --- | --- | ---| --- | --- | --- |
|0|0 0000 000|0|-6|0|0|0|
|最小的非规格化数|0 0000 001|0|-6|1/8|1/8|1/512|
||0 0000 010|0|-6|2/8|2/8|2/512|
||0 0000 011|0|-6|3/8|3/8|3/512|
||...|...|...|...|...|...|
||0 0000 110|0|-6|6/8|6/8|6/512|
|最大的非规格化数|0 0000 111|0|-6|7/8|7/8|7/512|
|最小的规格化数|0 0001 000|1|-6|0|8/8|8/512|
||0 0001 001|1|-6|1/8|9/8|9/512|
||...|...|...|...|...|...|
||0 0110 110|6|-1|6/8|14/8|14/16|
||0 0110 111|6|-1|7/8|15/8|15/16|
||0 0111 000|7|0|0|8/8|1|
||0 0111 001|7|0|1/8|9/8|9/8|
||0 0111 010|7|0|2/8|10/8|10/8|
||...|...|...|...|...|...|
|最大的规格化数|0 1110 110|14|7|6/8|14/8|224|
|最大的规格化数|0 1110 111|14|7|7/8|15/8|240|
|无穷大|0 1111 000|||||$+\infty$|


从上面这个例子可以非常直观的看出：从非规格化数到规格化数是平滑过渡的。这也是非规格化数取为 1 - Bias 而非 -Bias 的原因。
另外，我们也注意到，浮点数所表示的数字并非均匀分布的，|x|< 1 部分的数字密度比较大；同时超过一定范围之后，可以表示的整数将不再是连续的。
不能够准确描述的最小正整数是 $2^{n + 1} + 1$，对于 32 位单精度浮点数来说就是 $2^{24} + 1$，这个数远小于 32 位有符号整数所能精确表示的最大整数 $2^{31}$

在数值计算过程中，这个问题会比较突出，常见问题就是当大数与小数相加减时 大数吃小数，这个是数值计算方法讨论的话题。

### 浮点的舍入

对于数值 x，要舍入的上界 x1, 下界x2，如果 x 与上下界之差不等，则取最接近的。如果距离相同，默认方法是向偶数舍入（向下和向上同样距离），举个例子：1.01101 舍入 4 位时，可以选择向上  1.0111 或者向下 1.0110 ，向偶数舍入则选择 1.0110

因为精度的原因，这跟我们所期望的十进制的四舍五入表现可能不同。
假设我们对数字 1.445 进行舍入两位操作，得到的是1.45，符合预期。但当我们对 1.435 进行舍入两位操作时，得到的却是 1.43 而非 1.44。 原因是 1.43 距离 1.435 要比 1.44 要更近一些。   
`1.435` 的二进制形式为 0x3fb7ae14, sign = 0, exponent = 0x7f, fraction = 0x37ae14    
`1.44` 的二进制形式为 0x3fb851ec, sign = 0, exponent = 0x7f, fraction = 0x3851ec 差 41944   
`1.43` 的二进制形式为 0x3fb70a3d, sign = 0, exponent = 0x7f, fraction = 0x370a3d 差 41943   

## 最后
其实我也是在重新阅读这部分内容之后才发现浮点数编码设计的精妙之处，我并没有找到不直接设计为整数部分和小数部分的原因。有兴趣的同学可以完成 《深入理解计算机系统》配套的实验的 [data-lab](http://csapp.cs.cmu.edu/3e/labs.html)，自己实现 `int floatFloat2Int(float uf)` 可以帮助自己理解和记忆这块内容。

> 更多内容可以参阅 《深入理解计算机系统》第二章
