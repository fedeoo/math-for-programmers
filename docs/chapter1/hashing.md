# Hahsing

可以说，绝大多数程序员几乎每天都会与 `HashTable` 打交道，拿 JS 来说，Object 和 Array 的实现都涉及到 `HashTable`。这儿值得强调的是 Array，就 V8 来说，稀疏数组的底层实现就是 `HashTable`。这篇文章就简单谈谈 Hahsing 的实现。
我们先来描述一下问题，我们有一组来自全域 $U = {0, 1, ..., n - 1}$ 的关键字，映射到范围为 $[m]$ 的散列表上。我们希望散列的结果随机而且均匀，散列结果应该在 [1,...,m]。

## 除法散列法
大家都知道的一个简单函数-求余   

$h(k) = k \; mod \; m$

其中 k 是关键字，至于模数 m，比较经常听到的是 m 应该选一个素数。原因可能说的不大上来，其实这取决于关键字集合的特征。如果关键字集合是 [0, 1, 2, 3, 4, 5, 6, ...]，任意取一个非素数也没什么问题。如果关键字是 [10, 20, 30, 40, ...]，模数选择的刚好是 10， 那每个数的余数都是 0。当然对于关键字刚好是模数倍数的情况，即使模数是素数也是无法避免最糟糕的情况发生。我们再来试下模数选择 15，余数范围为 [0, 5, 10] 这个也不太好。
究其原因就是给定的关键字有同余特性，如果我们选择的模数刚好与关键字同余，也就是说假定关键字形式为 N = kn，模数 M = km。N % M = k(n % m) 所得的数范围就是 $[m]$ 而非 $[M=km]$，为了让 M 与 N 互质，简单的办法就是选择 M 为素数。

## 乘法散列法
这个实际应用中比较少见。利用关键字 k 乘上常数 A(0 < A < 1)，然后只取小数部分，最后乘以 m 向下取整。散列函数为：
$$h(k) = \left \lfloor m(kA \; mod \; 1) \right \rfloor$$

一个合适的 A 取值为 $A = (\sqrt{5} - 1) / 2$

## 字符串的散列

简单来说，就是我们需要把字符串$(a_1,...,a_n)$转换为整数，'0123456' 对于这样得到字符串，很容易想到转换为以基数 10 表示的整数。对于更一般的字符串我们可以想到 ASCII 字符集数 128 为基表示。一般化表示为
$$h((a_1,...,a_n)) = (\sum_{i=1}^{n}a_i*D^{i - 1}) \; mod \; m$$ 其中 D 是进制，模数 m 通常选择素数。
JDK 中 hashcode 的计算是 $(\sum_{i=1}^{n}a_i*31^{n - i}) \; mod \; 2^{32}$。进制 31 貌似没有什么特别之处，2^32 其实是利用自然溢出加快运算，在代码中也不会看到。


## 总结
Hahsing 涉及的数学知识属于数论，hash 涉及的内容并不多。在实际应用中，一些魔数的选择基于何种考虑，往往不得而知。下面有一篇参考文章讲解的比较深入。

> 相关文章   
[探究JS V8引擎下的“数组”底层实现](https://juejin.im/post/5d80919b51882538036fc87d)   
[hashing的一些正确姿势](https://zhuanlan.zhihu.com/p/104346215)   
[hashcode](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#hashCode())
